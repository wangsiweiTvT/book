---
layout: post
title: 案例研究：为什么我的公交车总是晚点？
---

下面我們給大家演示一個真正的數據分析的案例，讓大家體驗一下，我們真的到了工作崗位上，是怎麼分析數據的。我们首先定义清楚问题，然后初步分析数据 Scope，然后对数据进行探索性分析，理解数据，最后真正确定数据 Scope，获得车辆晚点数据，最后，通过仿真，获得用户等待时间的分布。

我们要分析的就是上节分析过的公交车数据。分析为什么我的公交车老是晚点。

## 问题定义

首先，我们把问题定义清楚。如前所述，问题应该要能够被数据回答，而且要清晰、聚焦、有意义。

我们首先把问题定义清晰、聚焦、有意义。我的问题是“为什么我的公交车总是晚点”。

我们先看“晚点”这个词。这个词到底是什么意思？我们是要研究公交车晚点时长的分布么？好像是的。但我们真的很关心车辆晚点了多久吗？可能公交车的司机或者管理人员是比较关心这个的，因为它其实是这些车辆运营人员的运维 KPI（关键性能指标）。

实际上，我们普通乘客，最关心的是我要等待多长时间，对吧？我们先思考一下理想的情况：公交车总是每隔十分钟到站，比如车总是九点十分、九点二十分、九点三十分准时到。这时，我们是不是也要等？假设我到达车站的时间是均匀分布的，比如我九点一分、两分、三分、四分到达的概率是一样的。那么，我的等待时间也是均匀分布的吧？我很可能等一分钟、两分钟、三分钟、四分钟，直到十分钟。所以我们的等待时间的均值就是五分钟。

所以，怎么研究“等待时间”呢？我们给乘客发送调查问卷？这个方法好像不太好。上面的分析提示我们：我们可以做仿真。我们如果有了车辆晚点的时间分布，就可以仿真乘客均匀到达车站时的等待时间。因此，我们首先要获得车辆晚点的时间分布。这看起来是能够得到数据支持的。

我们然后看“我的公交车”这个词？“我的公交车”，是我经常到的交大東路这个车站的车？还是我在北京去过的各种地方的车站的车？如果是交大东路这个车站的车，是马路这边往北的车站，还是马路那边往南的车站？如果是马路这边往北的车站，那么，是 618 路，还是 535 路？如果是 618 路，是要聚焦早 8 點的车，还是全天的车？这些关于“目标人群”的信息，或者控制变量，都和“我的公交车”这个词有关，是我们要事先想清楚的。

经过这个思考，我们初步确定想研究的是交大东路这个站全天的、我最常坐的 618 和 535 路，这两路公交车，双向车辆的晚点时间分布，然后利用这个晚点时间分布，仿真我均匀到达车站时的等待时间分布。这下我们的问题就清晰、聚焦、有意义了。

## 数据 Scope 分析

问题确定了，我們就可以分析数据的 Scope，看我们的问题能否被数据回答了。首先看数据的 Access Frame 情况。假设这个數據是整个城市的，时间跨度呢？假设它是好几个月的。数据质量呢？假设它是交管局提供的数据，已经经过了数据整理了，没有缺失值，数据也很全。这是数据的 Access Frame 情况。然后看我们要研究的问题的目标人群。因为我们最后确定要研究交大东路这个站全天的、我最常坐的 618 和 535 路，这两路公交车，双向车辆的晚点情况。那么，我们发现数据里对这两路车的数据是充分的，持续时间好几个月。因此，我们数据的 Access Frame 和研究的目标人群是匹配的。我们的问题能被数据回答。这就是我们对数据 Scope 的分析。

通过这个例子，我们的目的是请大家学会如何在数据中思考。怎么透过数据的迷雾，找到问题的答案。有的时候真的是迷雾啊，因为你的数据太大了，你根本不知道不知道怎么下手。然后数据非常复杂，你试图用它来跑一个模型，但根本不收敛，Loss 函数死活就不下降，一点招都没有。所以这里最核心的其实要学会如果思考。数据科学是个思考的科学啊。要想问题，在数据中思考，用数据来帮我们理解问题，展开思考。大家是不是喜欢看侦探小说。这个工作和侦探工作是差不多的。

## 数据整理

我们首先整理数据。这包括分三部分的工作。大家注意，这是数据科学最通用的数据整理三招。以后，不管你是打比赛，还是去做各种工作上的事情，就用这三招就行。一定要学会。

首先看数据质量。很多时候咱们就被质量不好的数据坑了。如果你的数据质量特别差，那么即使你后面的模型弄得特别好、你精通模型调优，也一点办法没有。然后做数据结构简化。怎么简化呢？就得理解这个数据，才能简化。最后做一些必要的转换，比如做 Log 转换。我们下面分别演示各部分的内容

## 数据清洗和观察

我们首先读入数据，清洗数据。我们用 Pandas 的函数 read_csv 读入数据，然后用 dropna 函数，把只要有“空”（na：not available）值的行（axis = 0）就去掉（drop）。注意，如果数据不太好的话，很可能你这么操作后，发现没几个数据了。那咱们就得想办法填充这个缺失值（用 fillna 函数）。在这里，因为数据质量还不错，没有太多空值，所以，我们就简单地丢掉有空值的行。

我们然后用函数 head 显示数据的前三行。这会给出数据的列名。我们看这些列名，就会发现一共有九列，包括日期、车辆 ID、路线、方向、站点 ID、站点名、计划到达时间、实际到达时间，等。

```py
bus = (pd.read_csv('data/seattle_bus_times.csv')
        .dropna(axis=0, how='any'))

bus.head(3)
```

我们然后统计一下每一列里面的内容的分布是什么。你看咱们有一列是 Stop ID，有一列是 Stop Name。我们就想了，这两个数据好像应该是一一对应的吧。这样的话，它们是不是冗余了？如果冗余的话，就可以简化掉一列。因此，我们就看看它们的值的分布。

在 Pandas 里，你要挑出几列，是什么语法呢？就是在 bus 这个 data frame 里，用方括号括起来一个 list，里面指定你要的列的列名。这样，你就能够把它们挑出来。好简单的吧。

然后，我们用 value_count 函数，对这些列里面的内容，进行分组，然后统计每一组出现了多少次。对，就相当于 SQL 里的 group by 然后 count。所以结果就是，北向，578 这个站点，在三大道，派克街，一共出现了 19,599 行；南向，431 站点，也是派克街，第三大道（看起来是派克街和三大道的交叉路口），出现了 19,318 个。大家理解 value_count 这个函数的作用了吗？这个很有用的啊。

从这个统计中我们可以看出：这两个站点的数据还挺多的，有分析的价值。如果就几十个数据，那咱们就不用再分析它了，因为样本数不够，对不对？所以这个统计是很重要的啊。咱们一般都要干这个事。通过这样的观察，我们也慢慢地建立了对问题上下文的理解，这是很重要的啊。

```py
bus[['DIR','STOP_ID','STOP_NAME']].value_counts()

DIR  STOP_ID  STOP_NAME
N    578      3RD AVE & PIKE ST (578)    19599
S    431      3RD AVE & PIKE ST (431)    19318
dtype: int64
```

## 数据变换

我们然后做数据转换。大家看这个“路线”和“方向”，它们原来的值是 “578” 和 “N” 这样的。那么，“578” 可能涉及到隐私，我们希望对它做“匿名化”；而 “N” 有点让人不太好理解，所以我们想把它替换为 “northbound”，这样后面画图的时候，更容易被人理解。所以，我们就用下面的代码做数据转换。

```py
def clean_stops(bus):
    return bus.assign(
        route=bus["RTE"].
        replace({673: "C", 674: "D", 675: "E"}),
        direction=bus["DIR"].
        replace({"N": "northbound", 
            "S": "southbound"}),
    )
```

大家看这段代码是怎么做的替换呢？这是 Pandas 的语法。这也是很重要的。它用 bus 这个 dataframe 的 assign 函数，给 bus 新加一列。这一列的名字就叫 root。那么这个 root 等于什么呢？等于这个 bus 的 RTE（路线）的这一列（注意它是一个 Series），调 replace 函数，把 673 换成 C，674 换成 D，675 换成 E。从这个代码中，大家要学会，怎么在一个 dataframe 里面，加一列。就是用 assign。然后，把一个 series 的内容替换的话，用 replace，就这么做就行了。类似的，我们再还加一列叫 direction，它把 DIR（方向）里的 N 和 S 分别换成 northbound 和 southbound。这是为了我们后面可视化画图的时候，在图中可以清楚地打印出来 northbound 和 southbound。这样更容易理解，

我们下面对时间进行转换。原数据中的时间是字符串，包括 date 和 time 两列。我们把它们加起来，变成一个新的字符串，里面即有日期又有时间，然后用 Pandas 的 to_datetime 函数，把这个字符串转成 Pandas 内置的timestamp 数据类型。这个 timestamp 数据类型非常有用。一旦你用了这个数据结构，你就可以很方便地提取它的年、月、星期几这些信息，然后做很多时间序列相关的操作。所以强烈推荐大家用这个 timestamp 数据类型。

```py
def compute_mins_late(bus):
    bus = bus.assign(
        scheduled=pd.to_datetime
        (bus["OPD_DATE"] + " " + bus["SCH_STOP_TM"]),
        actual=pd.to_datetime
        (bus["OPD_DATE"] + " " + bus["ACT_STOP_TM"]),
    )
```

我们然后把 scheduled 和 actual 时间相减，得到每一辆车到站的晚点时间。我们然后观察一下计算出来的晚点时间分布。还是用直方图画出来，并观察它们的最大、最小、中值。我们依次来观察它们。这很重要，往往能从中找到对问题上下文的更好理解。

首先看最小值。它是 -12。这意味着这个车早到了 12 分钟，有意思吧

然后看最大值。它是 2.5 个小时多。这太可怕了。这给我们一个很好的启发，它这么晚点的话，其实已经被别的车超过了，对吧？所以我们计算等待时间的时候，应该以车辆的到达时间来算。

最后看中值。中值还挺好的，只有一分钟不到。

我们然后看直方图。直方图给出的信息更多一些。我们当然可以从中看出最小值、最大值，我们还可以看出 Mode 值（出现次数最多的值）。特别是，我们可以看到，晚点时间超过 20 分钟的其实不多。所以那些晚点很长时间才到的车，都是很极端的情况，比如说车抛锚了。这种情况一年可能也就一两次，但是没办法，它给你弄得这么长。

怎么样，通过看这些值，是不是我们能够更好地感觉到这个数据，也感觉到我们的问题？

上面这些事情都是数据整理的事情，目的是后面分析和展示方便。注意，Pandas 有一个 Pipeline 的链式语法和基于 pipe 函数调用方法，如下面的代码所示

```py
bus = (
    pd.read_csv("data/seattle_bus_times.csv")
    .dropna(axis=0, how="any")
    .pipe(clean_stops)
    .pipe(compute_mins_late)
)

bus.head(3)
```

大家看上面的代码，通过 pipe 函数，我们就可以把数据读入、清洗、变换这样串起来。其中，pipe 函数的输入是我们的数据变换的函数。它的输入变量就是调 pipe 的 dataframe。这样我们的代码就特别干净。我们组队去打比赛的时候，可以不同的同学写不同的函数，然后这样穿起来。

## 数据简化

经过上面的数据变换后，我们加了好多列。现在数据里有 14 列。显然，其中的一些列现在冗余了。我不需要那么多列。
好，我只选择我需要的列：线路、方向、计划到达时间、实际到达时间、晚点的分钟数。就这 5 列就可以了。如下面的代码所示。其中时间都是 timestamp 数据类型的，方便后面做时间序列处理。

```py
bus = bus[["route", "direction", "scheduled", 
      "actual", "minutes_late"]]
```

这就是我们做数据整理的工作。看起来不难吧。我们总结一下，我们拿到了一个原始数据，然后 dropna，去掉了有空值的行，然后做数据变换，把有些列变得更好理解了（如方向），把有些列匿名化了（如线路），把时间的数据格式从字符串变成了 timestamp，以便后面好处理，算出了我们要研究的对象：车辆的晚点时长。期间，我们还做了统计分析，包括每一列的取值（用 value_count），观察了它的均值、中值、最小值、最大值、还有直方图分布。最后，简化了数据，只选了 5 列。这样，我们对数据有个基本的感觉，数据也特别干净，信息都有了。

## 数据探索

基于上述数据整理和初步理解的结果，我们现在进行数据探索，以更好地理解我们的研究问题，明确数据 Scope。

我们提出一个探索性的问题：车辆的晚点时长和什么有关呢？

首先，晚点时长跟路况有关。如果堵的话，就容易晚点。那我们怎么得到“路况”这个数据呢？虽然现在很多地图应用都有实时路况，但这在咱们五列的数据里，暂时还不具备。那么，在我们的五列数据里，哪一列能够间接地反映“路况”信息？

第一是车辆到达时间能够反映路况。以咱们的经验，早高峰和晚高峰时段，路况要堵一些，对吧？所以，晚点时长和 Time of Day 可能有关。如果有更长时期的数据，那么和就是五一、十一这种假日也可能有关系。对吧？

第二是路线也能反映路况。不同的线路，经过的地点不同，拥堵程度可能也不一样。比如有的线路经过长安街，但有的线路经过旅游景点，它们的晚点情况可能就不一样。所以晚点时间和线路可能有关。

其次，晚点时长和线路的方向有关。比如，有两个方向的车：一个在交大东路站是始发站，一个在交大东路站是终点站，请问它们的晚点时长是不是会不太一样？是始发站的晚点概率大，还是终点站晚点概率大？始发站不太会晚点吧？终点站的晚点概率有点大。所以，晚点时长和这个站点在这个线路上的方向也有关。

我们再提出一个探索性的问题：乘客的等待时间和什么有关呢？是不是和公交车的计划到达间隔也有关。如果它计划的每 5 分钟就来一辆，我们的等待时间是不是会少一点；如果它计划的是每 10 分钟来一辆，它的晚点时间可能会长一点。

那上面这些都是我们的分析、推理、或者猜测。到底是不是有关系呢？怎么办？我们下面进行可视化的探索性数据分析。

我们首先画出不同线路、不同方向的晚点时间分布，然后比较这些图，感觉它们是不是和线路、方向有关。代码如下所示：

```py
fig = px.histogram(
    bus,
    x='minutes_late', 
    histnorm='probability density', 
    nbins=200,
    facet_row='direction', 
    facet_col='route',
    facet_row_spacing=0.1,
    labels={'minutes_late':'Minutes late'},
    width=550, height=400)

fig.update_xaxes(range=[-12, 25])
fig.update_yaxes(range=[0, 0.3], title="")
margin(fig, t=25)
fig.show()
```

如上面的代码所示，我们还是调用 Plotly 的 histogram 函数。注意，这次，通过设置 histnorm = 'probability density'，我们将会画出它的 PDF 图，而不是出现的频率次数的统计图了。然后，我们通过指定 facet_row = 'direction' 和 facet_col = 'route'，自动画出多个子图。其中，每行是一个方向，每列是一条线。而且图中还把路线和方向的标签都标好了，比如 Route C，Northbound。各个子图的横轴、纵轴的尺度也是一样的，这样大家就好比较了。

从图中，我们就可以看出，同一条线路上，两个方向的车的晚点时长不同；而同一个方向上，不同路线的晚点时长也不同。这就验证了我们前面的推测。那么，换一个角度，假设我们前面没有这些推测，大家从这个图中，能推断出为什么会这样吗？比如，我们从中可以感觉到有什么规律吗？你看，南向的 E 线和 D 线类似，它们又和北向的 C 线类似。同样的，北向的 E 线和 D 线类似，它们又和南向的 C 线类似。这可能不是偶然的吧？所以画出了图后，我们开动脑筋想想，为什么会这样。一旦我们把这个原因想出来了，就对问题有了更深的理解，因此能够建立更准确的模型了，对不对？

我们然后画晚点时间和 Time of Day 的关系图。我们画 box 图。代码如下：

```py
bus['hour_of_day'] = bus['scheduled'].dt.hour
fig = px.box(
        bus, y='minutes_late', x='hour_of_day',
        facet_row='direction', facet_col='route',
        labels={'minutes_late':'Minutes late',
            'hour_of_day':'Hour of the day'},
        width=600, height=400)
fig.update_yaxes(range=[-12, 50])
margin(fig, t=25)
fig.show()
```

如上面的代码所示，我们首先从计划到达时间的 timestamp 数据结构中，用 dt.hour 提取出到达时间的 Time of Day。你看，这就是用 timestamp 数据格式的好处。非常方便就提取了这个 Time of Day。然后，我们在 bus 中又加了一列： hour of day。

我们然后用盒子图画出每个小时的晚点时间的 Box 图。它的横轴是 hour of day，纵轴是描述概率分布的 box。我们同样用 direction 做行，路线当列。这张图就反映了更细致的晚点时间分布随时间变化的规律。我们看，它的横轴是从前一天的晚上 12 点到第二天晚上 12 点，一共是 24 小时，所以一共有 24 个 box。那么什么是 box 图呢？box 图中间这个 box 代表 25% 和 75% 的两个 Percentile。然后它的尾巴，有各种定义方法。所以它反映的其实就是 box 这个范围内概率比较大。

从这张图上，我们可以看到晚点时长和 Time of Day 的相关性。比如说：上午和晚高峰的两个时间点的分布和其它时间的分布不同，比如，这时候有的车晚点都会晚 40 多分钟。这就验证了我们同学的猜想，就是晚点时长和路况有关，因为晚高峰堵车比较严重。现在我们已经用数据证明了这个猜想，挺好吧。所以我们从这种可视化的观察中，能找到很多感觉。

我们最后计算车辆的计划到达时间的间隔。代码如下：

```py
minute = pd.Timedelta('1 minute')
bus_c_n = (
    bus[(bus['route'] == 'C') 
    & (bus['direction'] == 'northbound')]
    .sort_values('scheduled')
    .assign(sched_inter=
    lambda x: x['scheduled'].diff() / minute))
```

如上面的代码所示，我们先选出 Route C 的北向的车辆，然后基于它们的计划到达时间，用 sort_values 函数对数据进行排序，最后用 Lambda 函数的方式，调用 diff 函数，获得计划到达时间的间隔，并将间隔除以“一分钟“的单位，得到分钟数，并填入 bus 中的 sched_inter 列中。

我们然后画直方图，观察获得的间隔时间，会发现 12 分钟的最多，15 分钟的也特别多。所以大部分间隔时间是 12 分钟到 15 分钟，说明它还是比较固定的。但是也有一些是 8 分钟，还有一些 30 分钟的。这时候你想想，为什么会有间隔30分钟的呢？可能是因为晚上，间隔时间长一点吧。我们当然也可以画一个 Time of Day 的 Box 图，对这个猜想进行观察。

小结一下，我们基于这五列数据，我们探索了一些问题。探索了晚点的时长跟什么有关，发现它跟线路有关、跟方向有关、跟 Time of Day 有关。我们还发现车辆的计划到达间隔时间是变化的。这些都是我们测量和建模的时候需要考虑的，比如，测量的时候，它们应该是控制变量，这样我们的测量结果，才能揭示真实世界的规律；模型的时候，它们应该是模型变量，这样我们的模型才能预测准确。这就是我们进行上述分析的原因。

## 模型（理解世界）和仿真（推理）

我们下面进行具体的模型（理解世界）和仿真（推理）工作了。

为了把影响到达延时的相关因素都控制住，我们就选出 Route C 的北向车辆，并且只选那些计划到达间隔为 12 分钟整的车辆。因为我们的数量足够多，所以这么做还是能够得到足够多的数据，支持我们的模型工作。这有点像我又把我的数据 Scope 缩小了。这样可以得到更加准确的模型。

我们然后画直方图，观察这些晚点时间的分布，发现最小值是 -10 分钟，最大值是 57 分钟，中值是 -0.5 分钟。这说明它早到还挺多。所以，咱们以后应该早点到，不能再卡着点到了，对不对？你看我们的数据分析多有价值。

下面我们来仿真乘客的等待时间。我们首先仿真车辆的计划到达时间，把一天 24 小时切成 12 分钟的间隔，然后在测量得到的晚点时间中，进行随机采样，然后把晚点时间，加到计划到达时间上，就得到了仿真的车辆真实到达时间。

大家注意，这里有一个容易出错的地方：因为有的车晚点了 57 分钟，这就意味着它的到达时间还落到别的车后面了，所以，现在的车辆真实到达时间序列，并不是完全从小到大排列的，有些前面的值比后面的值还大。所以，我们要把这个序列从小到大，再排序一下，得到有顺序的真实汽车到达时间。如果不排序的话，我们后面的计算会出错。

```py
scheduled = 12 * np.arange(91)

minutes_late = bus_c_n_12['minutes_late']
actual = scheduled +
    np.random.choice(minutes_late, size=91, replace=True)

actual.sort()
```

这就是为什么有的时候，咱们遇到一个数据科学的问题，死活弄不对，就是因为这些小事。这时候怎么办？所以我们要跟同学讨论，我们要把自己的方案跟同学讲，请她 Review，请她看你的代码，帮你做 Code Inspection。因为一个人的思维肯定是有黑洞的，你老觉得自己写的是对的。但是，你一跟别人讨论，别人可能一眼就看出来了，或者你说着说着，自己就反应过来了。所以，做科研，一定不能一个人做，绝对不能社恐，一定要一起做，就是这个原因。这是科研和考试最大的区别，因为科研是开放性的，它没有标准答案。所以，必须和外界交流，激荡思维，接受意见。真正的会科研的人，都是积极交流的人。

我们然后仿真 500个用户在一天内，均匀到达。我们初始化一个到达时间序列，然后对其进行抽样，得到仿真的用户到达时间。

```py
pass_arrival_times = np.arange(100*1068)

sim_arrival_times = (
    np.random.choice(pass_arrival_times, 
    size=500, replace=True) / 100
)
sim_arrival_times.sort()
```

我们然后用 numpy 的 searchsorted 函数，做有序搜索（这样运行的速度快），找到比乘客到达时间晚的最近一班车的时间，用它减去用户到达时间，就是乘客的真实等待时间。

```py
i = np.searchsorted(actual, 
    sim_arrival_times, side='right')

sim_wait_times = actual[i] - sim_arrival_times
```

类似的，我们仿真 200 天。然后画出等待时间的直方图。从分布中我们可以看出：等待时间的中值还真挺长，有 6.5 分钟；而且，它的 75% Precentile 值是 10.62 分钟，这就意味着，有 25% 的可能，要等待超过 10 分钟。

## 小结

这就是一个完整的数据科学的 lifecycle。首先是整理数据，然后是探索数据，确定数据 Scope，建立模型。我们探索了很多，发现晚点时间和路线、方向有关，到达时间间隔不是固定的。然后，进行仿真。我们仿真其实简化了很多，只考虑了一条路线，一个方向 12 分钟到达间隔的，没有考虑其他相关因素，比如晚高峰的影响，不同的线路，不同的用户到达速度，等等。但这个仿真结果依然是有启发的：我们发现了：有很多的等待时间是很长的，它是长尾的。我们用到的工具主要是 Pandas 和 Plotly。

所以大家吃惊吗，这样一个看起来很简单的问题，我们讲了 50 分钟。大家想想，这个项目，如果让大家答辩的话，8 分钟够吗？可能不够吧？没错。这就体现出你的研究来了。这就是做科研。我们要去分析数据，从中得到启发。这就是在数据中思考，透过数据的迷雾，找到问题的答案。数据科学是个思考的科学吧？这个工作和侦探工作是差不多的。

<br/>

|[Index](../) | [Previous](13-9-bus)|
